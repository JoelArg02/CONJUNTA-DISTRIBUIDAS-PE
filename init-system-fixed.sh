#!/bin/bash

# Script de inicializaci√≥n completa del sistema distribuido
# Este script construye las im√°genes Docker, despliega todo en Kubernetes y abre el dashboard

set -e  # Salir si cualquier comando falla

# Funci√≥n para mostrar ayuda
show_help() {
    echo "Uso: $0 [OPCIONES]"
    echo ""
    echo "Opciones:"
    echo "  --dashboard     Abrir dashboard primero para monitorear el proceso"
    echo "  --help          Mostrar esta ayuda"
    echo ""
    echo "Ejemplos:"
    echo "  $0                # Iniciar sistema normalmente"
    echo "  $0 --dashboard    # Iniciar sistema y abrir dashboard primero"
}

# Variables por defecto
OPEN_DASHBOARD_FIRST=false

# Procesar argumentos
while [[ $# -gt 0 ]]; do
    case $1 in
        --dashboard)
            OPEN_DASHBOARD_FIRST=true
            shift
            ;;
        --help)
            show_help
            exit 0
            ;;
        *)
            echo "Opci√≥n desconocida: $1"
            show_help
            exit 1
            ;;
    esac
done

echo "üöÄ Iniciando sistema distribuido completo..."
echo "================================================"

# Verificar si Docker est√° corriendo
if ! docker info > /dev/null 2>&1; then
    echo "‚ùå Docker no est√° corriendo. Por favor inicia Docker Desktop."
    exit 1
fi

# Verificar si kubectl est√° disponible
if ! command -v kubectl > /dev/null 2>&1; then
    echo "‚ùå kubectl no est√° instalado. Por favor inst√°lalo primero."
    exit 1
fi

# Verificar que Minikube est√© instalado
if ! command -v minikube > /dev/null 2>&1; then
    echo "‚ùå Minikube no est√° instalado"
    echo "üì• Instala Minikube desde: https://minikube.sigs.k8s.io/docs/start/"
    exit 1
fi

# Verificar estado de Minikube e iniciarlo si es necesario
echo "üîß Verificando estado de Minikube..."
MINIKUBE_STATUS=$(minikube status --format='{{.Host}}' 2>/dev/null || echo "Stopped")

if [ "$MINIKUBE_STATUS" != "Running" ]; then
    echo "üöÄ Iniciando Minikube (esto puede tomar unos minutos)..."
    echo "üíª Configuraci√≥n: 7GB RAM, 4 CPUs, 30GB disco"
    
    # Limpiar cualquier estado corrupto antes de iniciar
    echo "üßπ Limpiando estado previo de Minikube..."
    minikube delete --purge 2>/dev/null || true
    
    # Iniciar Minikube con configuraci√≥n limpia y m√°s recursos
    minikube start --driver=docker --memory=7000 --cpus=4 --disk-size=30g
    
    if [ $? -ne 0 ]; then
        echo "‚ùå Error iniciando Minikube"
        echo "üí° Intenta ejecutar manualmente:"
        echo "   minikube delete --purge"
        echo "   minikube start --driver=docker --memory=7000 --cpus=4 --disk-size=30g"
        exit 1
    fi
    
    echo "‚úÖ Minikube iniciado exitosamente"
else
    echo "‚úÖ Minikube ya est√° ejecut√°ndose"
    
    # Verificar que el container realmente existe
    if ! docker ps | grep -q minikube; then
        echo "‚ö†Ô∏è  Detectado estado inconsistente de Minikube. Reiniciando..."
        minikube delete --purge
        minikube start --driver=docker --memory=7000 --cpus=4 --disk-size=30g
        
        if [ $? -ne 0 ]; then
            echo "‚ùå Error reiniciando Minikube"
            exit 1
        fi
        
        echo "‚úÖ Minikube reiniciado exitosamente"
    fi
fi

# Configurar kubectl para usar Minikube
kubectl config use-context minikube

# Habilitar Ingress addon con manejo de errores
echo "üåê Habilitando Ingress Controller..."
if ! minikube addons enable ingress; then
    echo "‚ö†Ô∏è  Error habilitando Ingress. Intentando reiniciar Minikube..."
    minikube stop
    sleep 5
    minikube start --driver=docker --memory=7000 --cpus=4 --disk-size=30g
    
    # Intentar nuevamente
    if ! minikube addons enable ingress; then
        echo "‚ö†Ô∏è No se pudo habilitar Ingress Controller"
        echo "üí° Puedes continuar sin Ingress, pero no tendr√°s acceso v√≠a URLs amigables"
    else
        echo "‚úÖ Ingress Controller habilitado tras reinicio"
    fi
else
    echo "‚úÖ Ingress Controller habilitado"
fi

# Configurar Docker para usar el daemon de Minikube (necesario para construir im√°genes)
echo "üê≥ Configurando Docker para Minikube..."
eval $(minikube docker-env)

# Verificar contexto de Kubernetes
echo "üîç Verificando contexto de Kubernetes..."
CURRENT_CONTEXT=$(kubectl config current-context)
echo "üìã Contexto actual: $CURRENT_CONTEXT"
echo "üìã Minikube IP: $(minikube ip)"

# Abrir dashboard primero si se solicita
if [ "$OPEN_DASHBOARD_FIRST" = true ]; then
    echo "üöÄ Abriendo dashboard para monitoreo..."
    echo "üí° El dashboard se abrir√° en tu navegador para que puedas ver el progreso"
    nohup minikube dashboard > /dev/null 2>&1 &
    sleep 3
    echo "‚úÖ Dashboard abierto - puedes monitorear el progreso desde ah√≠"
    echo ""
fi

# Funci√≥n para construir una imagen Docker (con cache inteligente)
build_service() {
    local service=$1
    local port=$2
    echo "üèóÔ∏è Construyendo imagen Docker para $service..."
    
    cd $service
    
    # Verificar si la imagen ya existe
    if docker images --format "table {{.Repository}}:{{.Tag}}" | grep -q "$service:latest"; then
        echo "üì¶ Imagen $service:latest ya existe - Docker usar√° cache para optimizar"
    else
        echo "üì¶ Primera construcci√≥n de $service:latest"
    fi
    
    # Construir imagen (Docker autom√°ticamente usa cache cuando es posible)
    docker build -t $service:latest .
    cd ..
    
    echo "‚úÖ Imagen $service:latest lista"
}

# Limpiar solo recursos de Kubernetes (mantener im√°genes Docker)
echo "üßπ Limpiando recursos de Kubernetes (manteniendo im√°genes Docker)..."
echo "======================================================================"

# Solo eliminar el namespace de Kubernetes
kubectl delete namespace distribuidas-conjunta --ignore-not-found=true 2>/dev/null || true

echo "‚è≥ Esperando a que el namespace se elimine completamente..."
while kubectl get namespace distribuidas-conjunta > /dev/null 2>&1; do
    sleep 2
done

echo "‚úÖ Recursos de Kubernetes limpiados (im√°genes Docker preservadas)"
sleep 2

# Construir todas las im√°genes Docker
echo "üèóÔ∏è Construyendo im√°genes Docker..."
echo "=================================="

build_service "billing" "8080"
build_service "central" "8000"
build_service "inventory" "8082"

echo "‚úÖ Todas las im√°genes Docker construidas exitosamente"

# Las im√°genes se construyen autom√°ticamente en el daemon de Minikube
# gracias a eval $(minikube docker-env) ejecutado anteriormente
echo "‚úÖ Im√°genes disponibles en Minikube"

# Crear namespace si no existe
echo "üì¶ Creando namespace..."
kubectl apply -f k8s/namespace.yaml

# Aplicar configuraciones
echo "‚öôÔ∏è Aplicando ConfigMaps y Secrets..."
kubectl apply -f k8s/configmaps.yaml

# Desplegar bases de datos y servicios de infraestructura
echo "üíæ Desplegando infraestructura..."
echo "================================"

echo "üêò Desplegando PostgreSQL..."
kubectl apply -f k8s/postgresql/deployment.yaml

echo "üê¨ Desplegando MySQL..."
kubectl apply -f k8s/mysql/deployment.yaml

echo "üê∞ Desplegando RabbitMQ..."
kubectl apply -f k8s/rabbitmq/deployment.yaml

# Esperar a que la infraestructura est√© lista
echo "‚è≥ Esperando a que la infraestructura est√© lista..."
kubectl wait --for=condition=available --timeout=300s deployment/postgresql -n distribuidas-conjunta || {
    echo "‚ö†Ô∏è PostgreSQL tard√≥ mucho en iniciarse, continuando..."
}

kubectl wait --for=condition=available --timeout=300s deployment/mysql -n distribuidas-conjunta || {
    echo "‚ö†Ô∏è MySQL tard√≥ mucho en iniciarse, continuando..."
}

kubectl wait --for=condition=available --timeout=300s deployment/rabbitmq -n distribuidas-conjunta || {
    echo "‚ö†Ô∏è RabbitMQ tard√≥ mucho en iniciarse, continuando..."
}

echo "‚úÖ Infraestructura lista"

# Peque√±a pausa adicional para asegurar que los servicios est√©n completamente listos
echo "‚è≥ Esperando estabilizaci√≥n de servicios..."
sleep 30

# Desplegar servicios de aplicaci√≥n
echo "üèóÔ∏è Desplegando servicios de aplicaci√≥n..."
echo "========================================"

echo "üí∞ Desplegando Billing Service..."
kubectl apply -f k8s/billing/

echo "üè¢ Desplegando Central Service..."
kubectl apply -f k8s/central/

echo "üì¶ Desplegando Inventory Service..."
kubectl apply -f k8s/inventory/

# Aplicar Ingress
echo "üåê Aplicando configuraci√≥n de Ingress..."
kubectl apply -f k8s/ingress.yaml

# Esperar a que los servicios est√©n listos
echo "‚è≥ Esperando a que los servicios est√©n listos..."
kubectl wait --for=condition=available --timeout=300s deployment/billing -n distribuidas-conjunta || {
    echo "‚ö†Ô∏è Billing Service tard√≥ mucho en iniciarse"
}

kubectl wait --for=condition=available --timeout=300s deployment/central -n distribuidas-conjunta || {
    echo "‚ö†Ô∏è Central Service tard√≥ mucho en iniciarse"
}

kubectl wait --for=condition=available --timeout=300s deployment/inventory -n distribuidas-conjunta || {
    echo "‚ö†Ô∏è Inventory Service tard√≥ mucho en iniciarse"
}

# Mostrar estado del sistema
echo "üìä Estado del sistema:"
echo "====================="
kubectl get pods -n distribuidas-conjunta
echo ""
kubectl get services -n distribuidas-conjunta

# Configurar acceso externo usando t√∫nel de Minikube
echo ""
echo "üåê Configurando acceso externo..."
echo "==============================="

# Obtener IP de Minikube
MINIKUBE_IP=$(minikube ip)
echo "üìã IP de Minikube: $MINIKUBE_IP"

# Matar procesos de t√∫nel anteriores si existen
echo "üßπ Limpiando t√∫neles anteriores..."
pkill -f "minikube tunnel" 2>/dev/null || true
sleep 2

# Configurar t√∫nel de Minikube en segundo plano
echo "üöá Iniciando t√∫nel de Minikube..."
echo "üí° Se necesitan permisos de administrador para el t√∫nel"
nohup minikube tunnel > /tmp/minikube-tunnel.log 2>&1 &
TUNNEL_PID=$!

# Esperar a que el t√∫nel est√© activo
echo "‚è≥ Esperando que el t√∫nel est√© activo..."
sleep 10

# Verificar que el Ingress tenga IP
echo "üîç Verificando Ingress..."
for i in {1..30}; do
    INGRESS_IP=$(kubectl get ingress distribuidas-ingress -n distribuidas-conjunta -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
    if [ -n "$INGRESS_IP" ]; then
        echo "‚úÖ Ingress configurado con IP: $INGRESS_IP"
        break
    fi
    echo "   Esperando Ingress... (intento $i/30)"
    sleep 2
done

# Abrir el dashboard principal si no se abri√≥ antes
if [ "$OPEN_DASHBOARD_FIRST" = false ]; then
    echo "üöÄ Abriendo dashboard principal..."
    nohup minikube dashboard > /dev/null 2>&1 &
    sleep 3
fi

# Tambi√©n abrir RabbitMQ si est√° disponible
if [ -n "$INGRESS_IP" ]; then
    echo "üê∞ Intentando abrir RabbitMQ Management..."
    if command -v open > /dev/null 2>&1; then
        # macOS
        open http://distribuidas.local/rabbitmq > /dev/null 2>&1 || true
    elif command -v xdg-open > /dev/null 2>&1; then
        # Linux
        xdg-open http://distribuidas.local/rabbitmq > /dev/null 2>&1 || true
    fi
fi

echo ""
echo "üéâ ¬°Sistema distribuido iniciado exitosamente!"
echo "=============================================="
echo ""
if [ "$OPEN_DASHBOARD_FIRST" = true ]; then
    echo "üìä Dashboard ya abierto para monitoreo continuo"
else
    echo "üìä Dashboard disponible para monitoreo"
fi
echo ""
echo "üåç Servicios disponibles:"
if [ -n "$INGRESS_IP" ]; then
    echo "  üéõÔ∏è Minikube Dashboard:    http://127.0.0.1:xxxxx (se abri√≥ autom√°ticamente)"
    echo "  üí∞ Billing Service:      http://distribuidas.local/billing"
    echo "  üè¢ Central Service:      http://distribuidas.local/central"
    echo "  üì¶ Inventory Service:    http://distribuidas.local/inventory"
    echo "  üìä RabbitMQ Management:  http://distribuidas.local/rabbitmq (admin/rootpassword)"
    echo ""
    echo "üí° Aseg√∫rate de tener en /etc/hosts:"
    echo "   $INGRESS_IP distribuidas.local"
else
    echo "  ‚ö†Ô∏è Ingress no est√° disponible, usa port-forward manualmente:"
    echo "  kubectl port-forward service/billing 8080:8080 -n distribuidas-conjunta"
    echo "  kubectl port-forward service/central 8000:8000 -n distribuidas-conjunta"
    echo "  kubectl port-forward service/inventory 8082:8082 -n distribuidas-conjunta"
    echo "  kubectl port-forward service/rabbitmq-service 15672:15672 -n distribuidas-conjunta"
fi
echo ""
echo "üîß Comandos √∫tiles:"
echo "  üìä Ver dashboard:         minikube dashboard"
echo "  üìã Ver pods:              kubectl get pods -n distribuidas-conjunta"
echo "  üìã Ver servicios:         kubectl get services -n distribuidas-conjunta"
echo "  üìã Ver ingress:           kubectl get ingress -n distribuidas-conjunta"
echo "  üìã Ver logs (billing):    kubectl logs -f deployment/billing -n distribuidas-conjunta"
echo "  üìã Ver logs (central):    kubectl logs -f deployment/central -n distribuidas-conjunta"
echo "  üìã Ver logs (inventory):  kubectl logs -f deployment/inventory -n distribuidas-conjunta"
echo ""
echo "üõë Para detener el sistema:"
echo "  ./stop-system.sh"
echo ""
echo "üöá Para detener el t√∫nel:"
echo "  pkill -f 'minikube tunnel'"
echo ""
echo "üîÑ Para reiniciar (con dashboard desde el inicio):"
echo "  ./init-system.sh --dashboard"
